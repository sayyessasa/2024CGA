<!DOCTYPE html> 
<html lang="ja"> 
<head> 
    <meta charset="UTF-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>WebGL Animation</title> 
    <style> 
        body { margin: 0; } 
        canvas { display: block; } 
    </style> 
</head> 
<body> 
    <canvas id="glcanvas"></canvas> 

    <script> 
        const canvas = document.getElementById('glcanvas'); 
        const gl = canvas.getContext('webgl'); 

        // Canvasのリサイズ 
        function resizeCanvasToDisplaySize(canvas) { 
            const displayWidth = canvas.clientWidth; 
            const displayHeight = canvas.clientHeight; 

            if (canvas.width !== displayWidth || canvas.height !== displayHeight) { 
                canvas.width = displayWidth; 
                canvas.height = displayHeight; 
            } 
        } 

        function initWebGL() { 
            resizeCanvasToDisplaySize(canvas); 

            // WebGLコンテキストがない場合はエラーメッセージを表示 
            if (!gl) { 
                console.error("WebGLがサポートされていません。"); 
                return; 
            } 

            // ビューポートの設定 
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); 

            // クリアカラーの設定 (背景色) 
            gl.clearColor(0.0, 0.0, 0.0, 1.0); 

            // カラーバッファのクリア 
            gl.clear(gl.COLOR_BUFFER_BIT); 
        } 

        initWebGL(); 
    </script> 
</body> 
</html> 


function createShader(gl, type, source) { 
    const shader = gl.createShader(type); 
    gl.shaderSource(shader, source); 
    gl.compileShader(shader); 
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { 
        console.error("シェーダーのコンパイルに失敗しました: ", gl.getShaderInfoLog(shader)); 
        gl.deleteShader(shader); 
        return null; 
    } 
    return shader; 
} 

function createProgram(gl, vertexShader, fragmentShader) { 
    const program = gl.createProgram(); 
    gl.attachShader(program, vertexShader); 
    gl.attachShader(program, fragmentShader); 
    gl.linkProgram(program); 
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { 
        console.error("プログラムのリンクに失敗しました: ", gl.getProgramInfoLog(program)); 
        return null; 
    } 
    return program; 
} 

const vertexShaderSource = ` 
    attribute vec4 a_position; 
    uniform mat4 u_matrix; 
    void main(void) { 
        gl_Position = u_matrix * a_position; 
    } 
`; 

const fragmentShaderSource = ` 
    void main(void) { 
        gl_FragColor = vec4(1.0, 0.5, 0.0, 1.0); // オレンジ色 
    } 
`; 

function initShaders(gl) { 
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource); 
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource); 
    const program = createProgram(gl, vertexShader, fragmentShader); 
    return program; 
} 

function initBuffers(gl) { 
    const vertices = new Float32Array([ 
        0.0, 0.5, 0.0, 
       -0.5, -0.5, 0.0, 
        0.5, -0.5, 0.0, 
    ]); 

    const positionBuffer = gl.createBuffer(); 
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); 
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW); 

    return positionBuffer; 
} 

const program = initShaders(gl); 
const positionBuffer = initBuffers(gl); 

gl.useProgram(program); 

const positionLocation = gl.getAttribLocation(program, "a_position"); 
gl.enableVertexAttribArray(positionLocation); 
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); 
gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0); 



let angle = 0; 
const matrixLocation = gl.getUniformLocation(program, "u_matrix"); 

function drawScene() { 
    resizeCanvasToDisplaySize(canvas); 
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); 

    // 画面をクリア 
    gl.clear(gl.COLOR_BUFFER_BIT); 

    // 回転行列を作成 
    const radian = angle * Math.PI / 180; 
    const cosB = Math.cos(radian); 
    const sinB = Math.sin(radian); 
    const matrix = new Float32Array([ 
        cosB, sinB, 0, 0, 
       -sinB, cosB, 0, 0, 
        0, 0, 1, 0, 
        0, 0, 0, 1, 
    ]); 

    // 回転行列をシェーダーに送信 
    gl.uniformMatrix4fv(matrixLocation, false, matrix); 

    // 三角形を描画 
    gl.drawArrays(gl.TRIANGLES, 0, 3); 

    // 次のフレームで回転角度を増加 
    angle += 1; 

    requestAnimationFrame(drawScene); 
} 

// アニメーション開始 
drawScene();  
